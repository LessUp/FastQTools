#!/bin/bash
# scripts/lint
# 
# FastQTools 代码质量检查脚本 - 统一的格式化和静态分析工具
# 
# 使用示例:
#   ./scripts/lint check                     # 检查代码风格
#   ./scripts/lint format                    # 自动格式化
#   ./scripts/lint tidy                      # 运行 clang-tidy
#   ./scripts/lint all                       # 运行所有检查

set -euo pipefail

# 加载公共函数库
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/../lib/common.sh"

# =============================================================================
# 默认配置
# =============================================================================
COMMAND="check"
BUILD_DIR=""
STYLE_FILE=".clang-format"
TIDY_CONFIG=".clang-tidy"
FIX=false
VERBOSE=false
JOBS=$(get_cpu_cores)

# =============================================================================
# 帮助信息
# =============================================================================
print_usage() {
    print_usage_header "FastQTools 代码质量工具" "统一的代码格式化和静态分析工具"
    
    cat << 'EOF'
命令:
  check                     检查代码风格 (默认)
  format                    自动格式化代码
  format-check              仅检查格式（不修改）
  tidy                      运行 clang-tidy 静态分析
  tidy-fix                  运行 clang-tidy 并自动修复
  all                       运行所有检查
  
选项:
  -b, --build-dir DIR       构建目录（包含 compile_commands.json）
  -s, --style FILE          clang-format 样式文件 (默认: .clang-format)
  -t, --tidy-config FILE    clang-tidy 配置文件 (默认: .clang-tidy)
  -j, --jobs N              并行任务数 (默认: 自动检测)
  -v, --verbose             详细输出
  -h, --help                显示此帮助信息

示例:
  ./scripts/lint check                        # 检查代码风格
  ./scripts/lint format                       # 格式化所有代码
  ./scripts/lint tidy -b build-clang-release  # 运行静态分析
  ./scripts/lint tidy-fix                     # 自动修复问题
  ./scripts/lint all                          # 运行所有检查
EOF
}

# =============================================================================
# 检查工具可用性
# =============================================================================
check_tools() {
    local required_tools=("$@")
    local missing=()
    
    for tool in "${required_tools[@]}"; do
        if ! command -v "$tool" &>/dev/null; then
            missing+=("$tool")
        fi
    done
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        log_error "缺少必需工具: ${missing[*]}"
        log_info "安装提示:"
        log_info "  Ubuntu/Debian: sudo apt-get install clang-format clang-tidy"
        log_info "  macOS: brew install clang-format llvm"
        return 1
    fi
    return 0
}

# =============================================================================
# 格式化函数
# =============================================================================
run_format_check() {
    log_info "检查代码格式..."
    
    local files
    files=$(find src include tests \
        -type f \
        \( -name "*.cpp" -o -name "*.h" -o -name "*.hpp" \) \
        2>/dev/null)
    
    if [[ -z "$files" ]]; then
        log_warning "未找到需要检查的文件"
        return 0
    fi
    
    local issues=0
    while IFS= read -r file; do
        if ! clang-format --style=file:"$STYLE_FILE" --dry-run --Werror "$file" 2>/dev/null; then
            log_error "格式问题: $file"
            ((issues++))
        fi
    done <<< "$files"
    
    if [[ $issues -eq 0 ]]; then
        log_success "代码格式检查通过 ✓"
        return 0
    else
        log_error "发现 ${issues} 个文件有格式问题"
        log_info "运行 './scripts/lint format' 自动修复"
        return 1
    fi
}

run_format() {
    log_info "格式化代码..."
    
    local files
    files=$(find src include tests \
        -type f \
        \( -name "*.cpp" -o -name "*.h" -o -name "*.hpp" \) \
        2>/dev/null)
    
    if [[ -z "$files" ]]; then
        log_warning "未找到需要格式化的文件"
        return 0
    fi
    
    local count=0
    while IFS= read -r file; do
        if [[ "$VERBOSE" == "true" ]]; then
            log_debug "格式化: $file"
        fi
        clang-format --style=file:"$STYLE_FILE" -i "$file"
        ((count++))
    done <<< "$files"
    
    log_success "已格式化 ${count} 个文件 ✓"
    return 0
}

# =============================================================================
# Clang-Tidy 函数
# =============================================================================
run_tidy() {
    local fix_mode="$1"
    
    log_info "运行 clang-tidy 静态分析..."
    
    # 确定构建目录
    if [[ -z "$BUILD_DIR" ]]; then
        # 尝试查找编译数据库
        for dir in build-clang-* build-gcc-*; do
            if [[ -f "$dir/compile_commands.json" ]]; then
                BUILD_DIR="$dir"
                break
            fi
        done
        
        if [[ -z "$BUILD_DIR" ]]; then
            log_error "未找到构建目录"
            log_info "请先运行构建或使用 -b 指定构建目录"
            return 1
        fi
    fi
    
    if [[ ! -f "${BUILD_DIR}/compile_commands.json" ]]; then
        log_error "未找到编译数据库: ${BUILD_DIR}/compile_commands.json"
        log_info "请使用 -DCMAKE_EXPORT_COMPILE_COMMANDS=ON 重新构建"
        return 1
    fi
    
    log_info "使用编译数据库: ${BUILD_DIR}/compile_commands.json"
    
    # 收集源文件
    local files
    files=$(find src -type f \( -name "*.cpp" -o -name "*.h" \) 2>/dev/null)
    
    if [[ -z "$files" ]]; then
        log_warning "未找到需要分析的文件"
        return 0
    fi
    
    local tidy_args=(
        -p "$BUILD_DIR"
    )
    
    if [[ "$fix_mode" == "fix" ]]; then
        tidy_args+=(--fix --fix-errors)
        log_info "自动修复模式已启用"
    fi
    
    if [[ "$VERBOSE" == "false" ]]; then
        tidy_args+=(--quiet)
    fi
    
    local issues=0
    local count=0
    
    while IFS= read -r file; do
        ((count++))
        if [[ "$VERBOSE" == "true" ]]; then
            log_debug "分析 [${count}]: $file"
        fi
        
        if ! clang-tidy "${tidy_args[@]}" "$file" 2>&1 | tee /tmp/tidy_output.txt; then
            if grep -q "warning:" /tmp/tidy_output.txt || grep -q "error:" /tmp/tidy_output.txt; then
                ((issues++))
            fi
        fi
    done <<< "$files"
    
    rm -f /tmp/tidy_output.txt
    
    if [[ $issues -eq 0 ]]; then
        log_success "静态分析通过 ✓ (检查了 ${count} 个文件)"
        return 0
    else
        log_warning "发现 ${issues} 个文件有问题"
        if [[ "$fix_mode" != "fix" ]]; then
            log_info "运行 './scripts/lint tidy-fix' 尝试自动修复"
        fi
        return 1
    fi
}

# =============================================================================
# 参数解析
# =============================================================================
if [[ $# -gt 0 ]]; then
    case "$1" in
        check|format|format-check|tidy|tidy-fix|all)
            COMMAND="$1"
            shift
            ;;
    esac
fi

while [[ $# -gt 0 ]]; do
    case $1 in
        -b|--build-dir)
            BUILD_DIR="$2"
            shift 2
            ;;
        -s|--style)
            STYLE_FILE="$2"
            shift 2
            ;;
        -t|--tidy-config)
            TIDY_CONFIG="$2"
            shift 2
            ;;
        -j|--jobs)
            JOBS="$2"
            shift 2
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -h|--help)
            print_usage
            exit 0
            ;;
        *)
            log_error "未知选项: $1"
            print_usage
            exit 1
            ;;
    esac
done

# =============================================================================
# 执行命令
# =============================================================================
PROJECT_ROOT=$(get_project_root)
cd "$PROJECT_ROOT"

start_timer

log_section "FastQTools 代码质量检查"

case "$COMMAND" in
    check|format-check)
        check_tools clang-format || exit 1
        run_format_check
        RESULT=$?
        ;;
        
    format)
        check_tools clang-format || exit 1
        run_format
        RESULT=$?
        ;;
        
    tidy)
        check_tools clang-tidy || exit 1
        run_tidy "check"
        RESULT=$?
        ;;
        
    tidy-fix)
        check_tools clang-tidy || exit 1
        run_tidy "fix"
        RESULT=$?
        ;;
        
    all)
        check_tools clang-format clang-tidy || exit 1
        
        log_info "步骤 1/2: 代码格式检查"
        run_format_check
        FORMAT_RESULT=$?
        
        log_separator "-"
        
        log_info "步骤 2/2: 静态分析"
        run_tidy "check"
        TIDY_RESULT=$?
        
        if [[ $FORMAT_RESULT -eq 0 && $TIDY_RESULT -eq 0 ]]; then
            RESULT=0
        else
            RESULT=1
        fi
        ;;
        
    *)
        log_error "未知命令: $COMMAND"
        print_usage
        exit 1
        ;;
esac

log_separator "="

if [[ $RESULT -eq 0 ]]; then
    log_success "代码质量检查通过 ✓"
    end_timer
else
    log_error "代码质量检查失败 ✗"
fi

log_separator "="

exit $RESULT
