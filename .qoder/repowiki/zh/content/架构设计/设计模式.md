# 设计模式

<cite>
**本文档引用的文件**  
- [processing_pipeline_interface.h](file://include/fqtools/processing/processing_pipeline_interface.h)
- [statistic_calculator_interface.h](file://include/fqtools/statistics/statistic_calculator_interface.h)
- [factory.cpp](file://src/processing/factory.cpp)
- [fastq_reader.h](file://include/fqtools/io/fastq_reader.h)
- [fastq_reader.cpp](file://src/io/fastq_reader.cpp)
- [command_interface.h](file://src/cli/commands/command_interface.h)
- [filter_command.h](file://src/cli/commands/filter_command.h)
- [stat_command.h](file://src/cli/commands/stat_command.h)
- [read_mutator_interface.h](file://include/fqtools/processing/read_mutator_interface.h)
- [read_predicate_interface.h](file://include/fqtools/processing/read_predicate_interface.h)
</cite>

## 目录
1. [引言](#引言)
2. [接口抽象与多态](#接口抽象与多态)
3. [工厂模式](#工厂模式)
4. [Pimpl模式](#pimpl模式)
5. [命令模式](#命令模式)
6. [总结](#总结)

## 引言
本项目在设计和实现过程中采用了多种经典的设计模式，以提升代码的可维护性、可扩展性和解耦程度。本文档系统性地介绍了项目中应用的关键设计模式，包括接口抽象与多态、工厂模式、Pimpl模式和命令模式。这些模式共同构建了一个模块化、灵活且易于测试的架构，支持功能的动态扩展和组件的独立演化。

## 接口抽象与多态
项目通过定义清晰的接口（Interface）实现了抽象与多态，将高层逻辑与具体实现分离。这种设计不仅增强了模块间的解耦，还提高了代码的可测试性和可扩展性。

### ProcessingPipelineInterface
`ProcessingPipelineInterface` 定义了数据处理管道的公共API，包括设置输入输出路径、配置参数、注册数据修改器和过滤器，以及执行处理流程的方法。该接口通过纯虚函数强制派生类实现具体行为，客户端代码仅依赖于接口而非具体实现，从而实现了调用层与实现层的完全解耦。

### StatisticCalculatorInterface
`StatisticCalculatorInterface` 为统计计算任务提供了高层抽象，定义了`run()`方法作为执行入口。通过该接口，命令行层无需了解统计功能的具体实现细节，只需调用统一的接口即可完成任务调度。这种设计支持未来添加新的统计算法而无需修改现有代码，符合开闭原则。

### 读取处理器接口
项目还定义了`ReadMutatorInterface`和`ReadPredicateInterface`两个接口，分别用于数据修改和过滤操作。这些接口允许用户通过组合不同的实现来构建复杂的数据处理链，体现了策略模式的思想。客户端代码通过接口指针操作具体实现，实现了运行时的多态行为。

**Section sources**
- [processing_pipeline_interface.h](file://include/fqtools/processing/processing_pipeline_interface.h#L25-L167)
- [statistic_calculator_interface.h](file://include/fqtools/statistics/statistic_calculator_interface.h#L22-L64)
- [read_mutator_interface.h](file://include/fqtools/processing/read_mutator_interface.h#L6-L12)
- [read_predicate_interface.h](file://include/fqtools/processing/read_predicate_interface.h#L7-L13)

## 工厂模式
工厂模式被用于封装对象的创建过程，使客户端代码与具体类的实现解耦，支持系统的动态扩展和配置驱动的实例化。

### createProcessingPipeline
`factory.cpp` 中的 `createProcessingPipeline` 函数是一个典型的工厂函数，它返回一个指向 `ProcessingPipelineInterface` 的智能指针。该函数隐藏了 `SequentialProcessingPipeline` 这一具体实现类的细节，客户端无需包含其实现头文件即可创建实例。这种设计使得替换或扩展处理管道实现（如添加并行处理版本）变得简单且不影响现有代码。

### createStatisticCalculator
类似地，`createStatisticCalculator` 函数负责创建 `StatisticCalculatorInterface` 的具体实例。该函数位于工厂文件中，是整个系统中唯一需要了解 `FastqStatisticCalculator` 具体实现的地方。通过这种方式，实现了依赖倒置，降低了模块间的耦合度，便于单元测试中使用模拟对象（Mock）进行替换。

**Section sources**
- [factory.cpp](file://src/processing/factory.cpp#L21-L30)

## Pimpl模式
Pimpl（Pointer to Implementation）模式被用于隐藏类的内部实现细节，减少编译依赖，加快编译速度，并实现二进制兼容性。

### FastqReader 的 Pimpl 实现
`fastq_reader.h` 头文件中声明了 `FastqReader` 类，并通过前向声明的 `Impl` 结构体和 `std::unique_ptr<Impl>` 成员来实现 Pimpl 模式。公共接口仅暴露必要的方法，而所有与 zlib 压缩库、文件句柄和内部缓冲区相关的实现细节都被封装在 `fastq_reader.cpp` 文件中的 `Impl` 结构体内。这种设计使得头文件不依赖于第三方库的头文件，减少了包含依赖，提高了编译效率。

### 优势与应用
Pimpl 模式在此处的应用有效隔离了接口与实现，使得 `FastqReader` 的使用者无需了解其内部工作原理。即使内部实现发生重大变更（如更换压缩库），只要公共接口保持不变，客户端代码就无需重新编译。此外，该模式还支持移动语义的高效实现，避免了不必要的资源复制。

**Section sources**
- [fastq_reader.h](file://include/fqtools/io/fastq_reader.h#L17-L43)
- [fastq_reader.cpp](file://src/io/fastq_reader.cpp#L15-L37)

## 命令模式
命令模式将 CLI 命令封装为对象，实现了统一的调用接口，支持命令的动态注册和执行。

### CommandInterface 抽象基类
`command_interface.h` 定义了 `CommandInterface` 抽象基类，规定了所有子命令必须实现的接口，包括 `execute`、`getName` 和 `getDescription` 方法。这一设计将不同功能的命令（如 `filter` 和 `stat`）统一为同一类型，使得主程序可以以一致的方式处理所有命令。

### 具体命令实现
`FilterCommand` 和 `StatCommand` 类分别继承自 `CommandInterface`，实现了各自的功能逻辑。`main.cpp` 中的主函数通过命令名称查找对应的命令对象，并调用其 `execute` 方法。这种设计使得添加新命令变得非常简单：只需实现 `CommandInterface` 并在命令映射中注册即可，无需修改核心调度逻辑。

### 扩展性与维护性
命令模式的应用极大地提升了系统的扩展性。每个命令的实现完全独立，遵循单一职责原则。同时，由于所有命令都通过统一接口调用，主程序的控制流清晰简洁，易于维护和测试。错误处理也更加统一，异常可以在顶层被捕获和处理。

**Section sources**
- [command_interface.h](file://src/cli/commands/command_interface.h#L1-L20)
- [filter_command.h](file://src/cli/commands/filter_command.h#L24-L71)
- [stat_command.h](file://src/cli/commands/stat_command.h#L18-L43)
- [main.cpp](file://src/cli/main.cpp#L90-L111)

## 总结
本项目通过综合运用接口抽象、工厂模式、Pimpl模式和命令模式，构建了一个高度模块化、可扩展且易于维护的软件架构。接口抽象与多态实现了组件间的松耦合；工厂模式封装了对象创建，支持灵活配置；Pimpl模式隐藏了实现细节，减少了编译依赖；命令模式统一了命令处理流程，便于功能扩展。这些设计模式的协同作用，不仅提升了代码质量，也为未来的功能演进奠定了坚实的基础。